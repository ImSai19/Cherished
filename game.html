<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cherished Picture Puzzle</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap');

        :root {
            --primary-color: #2c003e;
            --secondary-color: #800080;
            --accent-color: #a400a4;
            --card-color: #3a0044;
            --text-color: #fff;
            --shadow-color: rgba(0, 0, 0, 0.5);
            --glow-color: rgba(164, 0, 164, 0.6);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background-color: var(--primary-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow-x: hidden;
            position: relative;
        }

        .stars {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
            pointer-events: none;
        }

        .star {
            position: absolute;
            width: 2px;
            height: 2px;
            background-color: white;
            border-radius: 50%;
            opacity: 0;
            animation: twinkle var(--duration) infinite ease-in-out;
            animation-delay: var(--delay);
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.5); }
        }

        .background-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: linear-gradient(125deg, #2c003e, #4a0072, #800080, #3a0044);
            background-size: 400% 400%;
            animation: gradientBG 15s ease infinite;
        }

        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .container {
            text-align: center;
            padding: 30px;
            border-radius: 20px;
            background-color: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3),
                        0 0 20px var(--glow-color);
            max-width: 95%;
            width: 850px;
            position: relative;
            overflow: hidden;
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            animation: zoomIn 1s cubic-bezier(0.68, -0.55, 0.27, 1.55) forwards;
            margin: 20px auto;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        @keyframes zoomIn {
            from {
                opacity: 0;
                transform: scale(0.8);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .container::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 70%);
            transform: rotate(45deg);
            pointer-events: none;
        }

        .container::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        }

        .title-animation {
            font-size: 2.5em;
            margin-bottom: 30px;
            position: relative;
            display: inline-block;
            background: linear-gradient(45deg, #fff, #d9a7e0, #fff);
            background-size: 200% auto;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 10px rgba(164, 0, 164, 0.3);
        }

        .title-animation::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 3px;
            background: linear-gradient(90deg, transparent, var(--accent-color), transparent);
            border-radius: 3px;
        }

        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 10;
            font-size: 1.2em;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .back-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(-3px) scale(1.1);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
        }

        .pulse-button {
            position: relative;
            padding: 18px 35px;
            background: linear-gradient(45deg, var(--secondary-color), var(--accent-color));
            border: none;
            border-radius: 50px;
            color: white;
            cursor: pointer;
            font-size: 18px;
            font-weight: 600;
            letter-spacing: 1px;
            overflow: hidden;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(128, 0, 128, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 25px auto;
            min-width: 180px;
        }

        .pulse-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.1);
            transform: scale(0);
            opacity: 0;
            border-radius: 50px;
            transition: all 0.5s;
        }

        .pulse-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(128, 0, 128, 0.6);
        }

        .pulse-button:hover::before {
            transform: scale(1.5);
            opacity: 0;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(0.9);
                opacity: 0.7;
            }
            50% {
                transform: scale(1.5);
                opacity: 0;
            }
            100% {
                transform: scale(0.9);
                opacity: 0;
            }
        }

        .image-selection {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 25px;
            margin: 30px 0;
            padding: 0 15px;
        }

        .image-option {
            position: relative;
            border-radius: 15px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transform: scale(1);
            aspect-ratio: 16/9;
            height: auto;
            animation: fadeInScale 0.6s ease forwards;
            opacity: 0;
            transform: scale(0.9);
        }

        @keyframes fadeInScale {
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .image-option:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 25px rgba(128, 0, 128, 0.6);
            z-index: 1;
        }

        .image-option img {
            width: 100%;
            height: 100%;
            object-fit: fill;
            display: block;
            transition: all 0.5s;
        }

        .image-option:hover img {
            transform: scale(1.1);
        }

        .image-option.selected {
            border: 3px solid var(--accent-color);
            box-shadow: 0 0 20px var(--glow-color);
        }

        .image-option .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .image-option:hover .overlay {
            opacity: 1;
        }

        .image-option .overlay-text {
            color: white;
            font-size: 1.4em;
            font-weight: 600;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            transform: translateY(20px);
            transition: transform 0.3s;
        }

        .image-option:hover .overlay-text {
            transform: translateY(0);
        }

        .difficulty-selection {
            margin: 25px 0;
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .difficulty-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 50px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 16px;
            font-weight: 500;
            min-width: 100px;
            position: relative;
            overflow: hidden;
        }

        .difficulty-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .difficulty-btn:hover::before {
            left: 100%;
        }

        .difficulty-btn:hover, .difficulty-btn.selected {
            background: var(--accent-color);
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        #puzzle-container {
            display: none;
            margin: 30px auto;
            position: relative;
            width: 450px;
            height: 450px;
            max-width: 100%;
            perspective: 1000px;
        }

        .puzzle-piece {
            position: absolute;
            background-size: cover;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            border-radius: 5px;
            backface-visibility: hidden;
        }

        .puzzle-piece:hover {
            transform: scale(1.05) translateZ(10px);
            z-index: 10;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5), 0 0 10px var(--glow-color);
        }

        .empty {
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed rgba(255, 255, 255, 0.3);
            box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.1);
        }

        .game-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 25px;
            flex-wrap: wrap;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            margin: 25px 0;
            padding: 15px 25px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50px;
            font-size: 1.1em;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .game-stat {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .game-stat i {
            color: var(--accent-color);
            font-size: 1.2em;
        }

        .win-message {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: all 0.5s;
            backdrop-filter: blur(8px);
        }

        .win-message.show {
            opacity: 1;
            visibility: visible;
        }

        .win-content {
            background: linear-gradient(135deg, var(--card-color), #4e005e);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            max-width: 90%;
            width: 500px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5), 0 0 30px var(--glow-color);
            transform: scale(0.8) rotate(-3deg);
            transition: transform 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            animation: confetti 5s ease-in-out infinite;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        .win-content::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 70%);
            transform: rotate(45deg);
            pointer-events: none;
        }

        .win-message.show .win-content {
            transform: scale(1) rotate(0deg);
        }

        @keyframes confetti {
            0%, 100% {
                box-shadow: 0 0 30px rgba(164, 0, 164, 0.6),
                            0 0 60px rgba(128, 0, 128, 0.4);
            }
            50% {
                box-shadow: 0 0 50px rgba(164, 0, 164, 0.8),
                            0 0 80px rgba(128, 0, 128, 0.6);
            }
        }

        .win-title {
            font-size: 2.5em;
            margin-bottom: 20px;
            color: #d9a7e0;
            text-shadow: 0 0 10px rgba(164, 0, 164, 0.5);
            position: relative;
            display: inline-block;
        }

        .win-title::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 3px;
            background: linear-gradient(90deg, transparent, var(--accent-color), transparent);
            border-radius: 3px;
        }

        .win-stats {
            margin: 25px 0;
            font-size: 1.3em;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.9);
        }

        .win-stats span {
            color: #d9a7e0;
            font-weight: 600;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            opacity: 0.8;
            animation: fall linear forwards;
        }

        @keyframes fall {
            to {
                transform: translateY(100vh) rotate(360deg);
            }
        }

        .hidden {
            display: none;
        }

        .preview-image {
            max-width: 180px;
            max-height: 180px;
            border-radius: 15px;
            margin: 25px auto;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3), 0 0 10px var(--glow-color);
            display: none;
            border: 2px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s;
        }

        .preview-image:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4), 0 0 15px var(--glow-color);
        }

        .selection-description {
            margin: 15px 0 25px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 1.1em;
            line-height: 1.6;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }

        .difficulty-label {
            margin-top: 30px;
            font-size: 1.2em;
            color: #d9a7e0;
            font-weight: 500;
        }

        .progress-container {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            margin: 15px 0;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--secondary-color), var(--accent-color));
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 4px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
                width: 95%;
            }
            
            .title-animation {
                font-size: 1.8em;
            }
            
            .image-selection {
                grid-template-columns: 1fr;
            }
            
            #puzzle-container {
                width: 300px;
                height: 300px;
            }
            
            .difficulty-selection {
                flex-wrap: wrap;
            }
            
            .game-info {
                flex-direction: column;
                gap: 10px;
                align-items: center;
                padding: 15px;
            }

            .back-button {
                top: 15px;
                left: 15px;
                width: 40px;
                height: 40px;
                font-size: 1em;
            }

            .win-title {
                font-size: 2em;
            }

            .win-stats {
                font-size: 1.1em;
            }
        }
    </style>
</head>
<body>
    <div class="background-animation"></div>
    <div class="stars" id="stars"></div>
   
    <a href="index.html" class="back-button" title="Back to Home">
        <i class="fas fa-arrow-left"></i>
    </a>

    <div class="container">
        <h1 class="title-animation">Cherished Picture Puzzle</h1>
        
        <div id="selection-screen">
            <p class="selection-description">Choose an image for your puzzle and challenge yourself with different difficulty levels. Rearrange the pieces to complete the picture!</p>
            
            <div class="image-selection">
                <div class="image-option" data-image="/images/pic1.jpg">
                    <img src="/images/pic1.jpg" alt="Sainath">
                    <div class="overlay">
                        <div class="overlay-text">Sainath</div>
                    </div>
                </div>
                <div class="image-option" data-image="/images/pic2.jpg">
                    <img src="/images/pic2.jpg" alt="Vaishnavi">
                    <div class="overlay">
                        <div class="overlay-text">Vaishnavi</div>
                    </div>
                </div>
                <div class="image-option" data-image="/images/pic3.jpg">
                    <img src="/images/pic3.jpg" alt="Guddi">
                    <div class="overlay">
                        <div class="overlay-text">Guddi</div>
                    </div>
                </div>
                <div class="image-option" data-image="/images/pic4.jpg">
                    <img src="/images/pic4.jpg" alt="City Skyline">
                    <div class="overlay">
                        <div class="overlay-text">City Skyline</div>
                    </div>
                </div>
            </div>
            
            <p class="difficulty-label">Select Difficulty Level</p>
            <div class="difficulty-selection">
                <button class="difficulty-btn selected" data-difficulty="easy">Easy</button>
                <button class="difficulty-btn" data-difficulty="medium">Medium</button>
                <button class="difficulty-btn" data-difficulty="hard">Hard</button>
            </div>
            
            <button class="pulse-button" id="start-button">
                <i class="fas fa-play"></i>
                <span>Start Puzzle</span>
            </button>
        </div>
        
        <div id="puzzle-container">
            <!-- Puzzle pieces will be generated here dynamically -->
        </div>
        
        <div class="progress-container hidden" id="progress-container">
            <div class="progress-bar" id="progress-bar"></div>
        </div>
        
        <div class="game-controls">
            <button class="pulse-button" id="shuffle-button">
                <i class="fas fa-random"></i>
                <span>Shuffle</span>
            </button>
            <button class="pulse-button" id="reset-button">
                <i class="fas fa-redo"></i>
                <span>Reset</span>
            </button>
        </div>
        
        <div class="game-info">
            <div class="game-stat">
                <i class="fas fa-clock"></i>
                <span id="timer">00:00</span>
            </div>
            <div class="game-stat">
                <i class="fas fa-check"></i>
                <span id="moves">Moves: 0</span>
            </div>
        </div>
    </div>
    
    <div class="win-message" id="win-message">
        <div class="win-content">
            <h2 class="win-title">Congratulations!</h2>
            <p class="win-stats">You completed the puzzle in <span id="final-time">00:00</span> with <span id="final-moves">0</span> moves!</p>
            <button class="pulse-button" id="restart-button">
                <i class="fas fa-play-circle"></i>
                <span>Play Again</span>
            </button>
        </div>
    </div>
    
    <script>
        // JavaScript functionality for puzzle game
        const imageOptions = document.querySelectorAll('.image-option');
        const difficultyButtons = document.querySelectorAll('.difficulty-btn');
        const startButton = document.getElementById('start-button');
        const puzzleContainer = document.getElementById('puzzle-container');
        const winMessage = document.getElementById('win-message');
        const finalTime = document.getElementById('final-time');
        const finalMoves = document.getElementById('final-moves');
        const timerDisplay = document.getElementById('timer');
        const movesDisplay = document.getElementById('moves');
        const shuffleButton = document.getElementById('shuffle-button');
        const resetButton = document.getElementById('reset-button');
        const restartButton = document.getElementById('restart-button');
        const selectionScreen = document.getElementById('selection-screen');
        const progressContainer = document.getElementById('progress-container');
        const progressBar = document.getElementById('progress-bar');

        let selectedImage = '';
        let selectedDifficulty = 'easy';
        let timer;
        let moves = 0;
        let puzzleSize = 3; // Default for easy
        let emptyTile = { row: 0, col: 0 };
        let puzzleState = [];
        let solvedState = [];
        let gameStarted = false;
        let totalPieces = 0;
        let correctPieces = 0;

        // Create stars background
        createStars();

        function createStars() {
            const starsContainer = document.createElement('div');
            starsContainer.className = 'stars';
            document.body.appendChild(starsContainer);
            
            const starCount = 100;
            
            for (let i = 0; i < starCount; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                
                // Random position and animation
                const x = Math.random() * 100;
                const y = Math.random() * 100;
                const duration = Math.random() * 3 + 2;
                const delay = Math.random() * 5;
                
                star.style.left = `${x}%`;
                star.style.top = `${y}%`;
                star.style.setProperty('--duration', `${duration}s`);
                star.style.setProperty('--delay', `${delay}s`);
                
                starsContainer.appendChild(star);
            }
        }

        // Set first image as selected by default
        if (imageOptions.length > 0) {
            imageOptions[0].classList.add('selected');
            selectedImage = imageOptions[0].dataset.image;
        }

        // Add animation to image options
        imageOptions.forEach((option, index) => {
            option.style.animationDelay = `${index * 0.1}s`;
            
            option.addEventListener('click', () => {
                imageOptions.forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');
                selectedImage = option.dataset.image;
            });
        });

        difficultyButtons.forEach(button => {
            button.addEventListener('click', () => {
                difficultyButtons.forEach(btn => btn.classList.remove('selected'));
                button.classList.add('selected');
                selectedDifficulty = button.dataset.difficulty;
            });
        });

        startButton.addEventListener('click', () => {
            if (selectedImage) {
                // Add exit animation to selection screen
                selectionScreen.style.animation = 'fadeOut 0.5s forwards';
                
                setTimeout(() => {
                    selectionScreen.style.display = 'none';
                    puzzleContainer.style.display = 'block';
                    document.querySelector('.game-controls').style.display = 'flex';
                    document.querySelector('.game-info').style.display = 'flex';
                    progressContainer.classList.remove('hidden');
                    startPuzzle();
                }, 500);
            } else {
                alert('Please select an image!');
            }
        });

        shuffleButton.addEventListener('click', () => {
            if (gameStarted) {
                shufflePuzzle();
            }
        });

        resetButton.addEventListener('click', () => {
            if (gameStarted) {
                resetPuzzle();
            }
        });

        restartButton.addEventListener('click', () => {
            winMessage.classList.remove('show');
            selectionScreen.style.display = 'block';
            puzzleContainer.style.display = 'none';
            document.querySelector('.game-controls').style.display = 'none';
            document.querySelector('.game-info').style.display = 'none';
            progressContainer.classList.add('hidden');
            gameStarted = false;
            clearInterval(timer);
            
            // Reset animation for selection screen
            selectionScreen.style.animation = '';
        });

        function startPuzzle() {
            // Set puzzle size based on difficulty
            switch (selectedDifficulty) {
                case 'easy':
                    puzzleSize = 3;
                    break;
                case 'medium':
                    puzzleSize = 4;
                    break;
                case 'hard':
                    puzzleSize = 5;
                    break;
            }

            // Initialize puzzle pieces and start timer
            moves = 0;
            movesDisplay.innerText = `Moves: ${moves}`;
            timerDisplay.innerText = '00:00';
            clearInterval(timer);
            
            let startTime = Date.now();
            timer = setInterval(() => {
                let elapsed = Math.floor((Date.now() - startTime) / 1000);
                let minutes = String(Math.floor(elapsed / 60)).padStart(2, '0');
                let seconds = String(elapsed % 60).padStart(2, '0');
                timerDisplay.innerText = `${minutes}:${seconds}`;
            }, 1000);

            // Generate puzzle pieces based on selected image and difficulty
            generatePuzzle();
            gameStarted = true;
            
            // Initialize progress
            totalPieces = puzzleSize * puzzleSize;
            correctPieces = 0;
            updateProgress();
        }

        function generatePuzzle() {
            puzzleContainer.innerHTML = '';
            puzzleState = [];
            solvedState = [];

            // Set container dimensions
            const containerSize = window.innerWidth > 768 ? 450 : 300;
            puzzleContainer.style.width = `${containerSize}px`;
            puzzleContainer.style.height = `${containerSize}px`;

            const tileSize = containerSize / puzzleSize;

            // Create puzzle pieces
            for (let row = 0; row < puzzleSize; row++) {
                puzzleState[row] = [];
                solvedState[row] = [];
                
                for (let col = 0; col < puzzleSize; col++) {
                    const tileValue = row * puzzleSize + col;
                    
                    // Create tile
                    const tile = document.createElement('div');
                    tile.className = 'puzzle-piece';
                    tile.dataset.row = row;
                    tile.dataset.col = col;
                    tile.dataset.value = tileValue;
                    
                    // Set tile position and size
                    tile.style.width = `${tileSize}px`;
                    tile.style.height = `${tileSize}px`;
                    tile.style.left = `${col * tileSize}px`;
                    tile.style.top = `${row * tileSize}px`;
                    
                    // Add entrance animation
                    tile.style.opacity = '0';
                    tile.style.transform = 'scale(0.8) rotate(' + (Math.random() * 10 - 5) + 'deg)';
                    
                    // Set background image position
                    if (row === puzzleSize - 1 && col === puzzleSize - 1) {
                        // Empty tile
                        tile.classList.add('empty');
                        emptyTile = { row, col };
                        puzzleState[row][col] = -1; // -1 represents empty tile
                    } else {
                        tile.style.backgroundImage = `url(${selectedImage})`;
                        tile.style.backgroundSize = `${containerSize}px ${containerSize}px`;
                        tile.style.backgroundPosition = `-${col * tileSize}px -${row * tileSize}px`;
                        
                        puzzleState[row][col] = tileValue;
                    }
                    
                    solvedState[row][col] = tileValue;
                    
                    // Add click event
                    tile.addEventListener('click', () => {
                        if (gameStarted) {
                            moveTile(parseInt(tile.dataset.row), parseInt(tile.dataset.col));
                        }
                    });
                    
                    puzzleContainer.appendChild(tile);
                    
                    // Animate tile entrance with delay
                    setTimeout(() => {
                        tile.style.opacity = '1';
                        tile.style.transform = 'scale(1) rotate(0deg)';
                    }, (row * puzzleSize + col) * 50);
                }
            }
            
            // Set the last tile in solved state as empty
            solvedState[puzzleSize-1][puzzleSize-1] = -1;
            
            // Shuffle the puzzle after a short delay to show the complete image first
            setTimeout(() => {
                shufflePuzzle();
            }, puzzleSize * puzzleSize * 50 + 500);
        }

        function moveTile(row, col) {
            // Check if the clicked tile is adjacent to the empty tile
            if (
                (Math.abs(row - emptyTile.row) === 1 && col === emptyTile.col) ||
                (Math.abs(col - emptyTile.col) === 1 && row === emptyTile.row)
            ) {
                // Swap the tiles
                const clickedTile = document.querySelector(`.puzzle-piece[data-row="${row}"][data-col="${col}"]`);
                const emptyTileElement = document.querySelector(`.puzzle-piece[data-row="${emptyTile.row}"][data-col="${emptyTile.col}"]`);
                
                // Add movement animation
                clickedTile.style.transition = 'left 0.2s ease, top 0.2s ease, transform 0.2s ease';
                emptyTileElement.style.transition = 'left 0.2s ease, top 0.2s ease';
                
                // Play sound effect
                playMoveSound();
                
                // Swap positions
                const tempLeft = clickedTile.style.left;
                const tempTop = clickedTile.style.top;
                
                clickedTile.style.left = emptyTileElement.style.left;
                clickedTile.style.top = emptyTileElement.style.top;
                clickedTile.style.transform = 'scale(1.05)';
                
                emptyTileElement.style.left = tempLeft;
                emptyTileElement.style.top = tempTop;
                
                // Reset transform after animation
                setTimeout(() => {
                    clickedTile.style.transform = 'scale(1)';
                }, 200);
                
                // Update data attributes
                clickedTile.dataset.row = emptyTile.row;
                clickedTile.dataset.col = emptyTile.col;
                
                emptyTileElement.dataset.row = row;
                emptyTileElement.dataset.col = col;
                
                // Update puzzle state
                puzzleState[emptyTile.row][emptyTile.col] = puzzleState[row][col];
                puzzleState[row][col] = -1;
                
                // Update empty tile position
                emptyTile = { row, col };
                
                // Increment moves
                moves++;
                movesDisplay.innerText = `Moves: ${moves}`;
                
                // Update progress
                updateProgress();
                
                // Check if puzzle is solved
                if (isPuzzleSolved()) {
                    gameWon();
                }
            }
        }

        function updateProgress() {
            correctPieces = 0;
            
            // Count correct pieces
            for (let row = 0; row < puzzleSize; row++) {
                for (let col = 0; col < puzzleSize; col++) {
                    if (puzzleState[row][col] === solvedState[row][col]) {
                        correctPieces++;
                    }
                }
            }
            
            // Update progress bar
            const progressPercentage = (correctPieces / totalPieces) * 100;
            progressBar.style.width = `${progressPercentage}%`;
        }

        function playMoveSound() {
            // Create a simple audio effect for tile movement
            const audio = new Audio();
            audio.volume = 0.2;
            
            // Use different sounds randomly for variety
            const soundIndex = Math.floor(Math.random() * 3) + 1;
            
            switch (soundIndex) {
                case 1:
                    audio.src = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=';
                    break;
                case 2:
                    audio.src = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=';
                    break;
                case 3:
                    audio.src = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=';
                    break;
            }
            
            audio.play().catch(e => {
                // Silent error - some browsers block autoplay
                console.log('Audio playback was prevented by the browser');
            });
        }

        function shufflePuzzle() {
            // Perform random moves to shuffle the puzzle
            const shuffleMoves = puzzleSize * puzzleSize * 10; // Number of random moves
            
            // Disable click events during shuffle
            gameStarted = false;
            
            // Show shuffling animation
            const pieces = document.querySelectorAll('.puzzle-piece');
            pieces.forEach(piece => {
                piece.style.transition = 'all 0.2s ease';
                piece.style.transform = 'scale(0.95) rotate(' + (Math.random() * 10 - 5) + 'deg)';
            });
            
            setTimeout(() => {
                pieces.forEach(piece => {
                    piece.style.transform = 'scale(1) rotate(0deg)';
                });
                
                // Perform the actual shuffle
                for (let i = 0; i < shuffleMoves; i++) {
                    // Get adjacent tiles to empty tile
                    const adjacentTiles = [];
                    
                    if (emptyTile.row > 0) {
                        adjacentTiles.push({ row: emptyTile.row - 1, col: emptyTile.col });
                    }
                    if (emptyTile.row < puzzleSize - 1) {
                        adjacentTiles.push({ row: emptyTile.row + 1, col: emptyTile.col });
                    }
                    if (emptyTile.col > 0) {
                        adjacentTiles.push({ row: emptyTile.row, col: emptyTile.col - 1 });
                    }
                    if (emptyTile.col < puzzleSize - 1) {
                        adjacentTiles.push({ row: emptyTile.row, col: emptyTile.col + 1 });
                    }
                    
                    // Choose a random adjacent tile
                    const randomTile = adjacentTiles[Math.floor(Math.random() * adjacentTiles.length)];
                    
                    // Move the tile (without incrementing moves counter)
                    const clickedTile = document.querySelector(`.puzzle-piece[data-row="${randomTile.row}"][data-col="${randomTile.col}"]`);
                    const emptyTileElement = document.querySelector(`.puzzle-piece[data-row="${emptyTile.row}"][data-col="${emptyTile.col}"]`);
                    
                    // Swap positions
                    const tempLeft = clickedTile.style.left;
                    const tempTop = clickedTile.style.top;
                    
                    clickedTile.style.left = emptyTileElement.style.left;
                    clickedTile.style.top = emptyTileElement.style.top;
                    
                    emptyTileElement.style.left = tempLeft;
                    emptyTileElement.style.top = tempTop;
                    
                    // Update data attributes
                    clickedTile.dataset.row = emptyTile.row;
                    clickedTile.dataset.col = emptyTile.col;
                    
                    emptyTileElement.dataset.row = randomTile.row;
                    emptyTileElement.dataset.col = randomTile.col;
                    
                    // Update puzzle state
                    puzzleState[emptyTile.row][emptyTile.col] = puzzleState[randomTile.row][randomTile.col];
                    puzzleState[randomTile.row][randomTile.col] = -1;
                    
                    // Update empty tile position
                    emptyTile = randomTile;
                }
                
                // Reset moves counter
                moves = 0;
                movesDisplay.innerText = `Moves: ${moves}`;
                
                // Update progress
                updateProgress();
                
                // Re-enable click events
                gameStarted = true;
            }, 300);
        }

        function resetPuzzle() {
            // Reset the puzzle to its initial state
            clearInterval(timer);
            startPuzzle();
        }

        function isPuzzleSolved() {
            // Check if current state matches solved state
            for (let row = 0; row < puzzleSize; row++) {
                for (let col = 0; col < puzzleSize; col++) {
                    if (puzzleState[row][col] !== solvedState[row][col]) {
                        return false;
                    }
                }
            }
            return true;
        }

        function gameWon() {
            // Stop the timer
            clearInterval(timer);
            
            // Update win message
            finalTime.textContent = timerDisplay.textContent;
            finalMoves.textContent = moves;
            
            // Show win message with delay for dramatic effect
            setTimeout(() => {
                winMessage.classList.add('show');
                
                // Create confetti effect
                createConfetti();
                
                // Play victory sound
                playVictorySound();
            }, 500);
            
            // Game is no longer in progress
            gameStarted = false;
        }

        function playVictorySound() {
            const audio = new Audio();
            audio.volume = 0.3;
            audio.src = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=';
            audio.play().catch(e => {
                // Silent error - some browsers block autoplay
                console.log('Audio playback was prevented by the browser');
            });
        }

        function createConfetti() {
            // Add confetti particles to celebrate winning
            const confettiCount = 200;
            const container = document.body;
            
            const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ffffff', '#ff8800', '#8800ff'];
            
            for (let i = 0; i < confettiCount; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                
                // Random position, color, size and animation duration
                const size = Math.random() * 10 + 5;
                confetti.style.width = `${size}px`;
                confetti.style.height = `${size}px`;
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.left = `${Math.random() * 100}vw`;
                confetti.style.top = `-${size}px`;
                confetti.style.animationDuration = `${Math.random() * 3 + 2}s`;
                
                // Add some rotation and different shapes
                const shapeType = Math.floor(Math.random() * 3);
                if (shapeType === 1) {
                    confetti.style.borderRadius = '50%'; // Circle
                } else if (shapeType === 2) {
                    confetti.style.borderRadius = '0'; // Square
                    confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
                } else {
                    confetti.style.clipPath = 'polygon(50% 0%, 0% 100%, 100% 100%)'; // Triangle
                }
                
                container.appendChild(confetti);
                
                // Remove confetti after animation
                setTimeout(() => {
                    confetti.remove();
                }, 5000);
            }
        }

        // Initialize the game
        document.addEventListener('DOMContentLoaded', () => {
            // Hide game controls and info initially
            document.querySelector('.game-controls').style.display = 'none';
            document.querySelector('.game-info').style.display = 'none';
            
            // Select first difficulty button by default
            if (difficultyButtons.length > 0) {
                difficultyButtons[0].classList.add('selected');
            }
            
            // Add animation to image options with delay
            imageOptions.forEach((option, index) => {
                setTimeout(() => {
                    option.style.opacity = '1';
                    option.style.transform = 'scale(1)';
                }, index * 100);
            });
            
            // Add keyboard controls
            document.addEventListener('keydown', (e) => {
                if (!gameStarted) return;
                
                switch(e.key) {
                    case 'ArrowUp':
                        // Move tile below empty space
                        if (emptyTile.row < puzzleSize - 1) {
                            moveTile(emptyTile.row + 1, emptyTile.col);
                        }
                        break;
                    case 'ArrowDown':
                        // Move tile above empty space
                        if (emptyTile.row > 0) {
                            moveTile(emptyTile.row - 1, emptyTile.col);
                        }
                        break;
                    case 'ArrowLeft':
                        // Move tile to the right of empty space
                        if (emptyTile.col < puzzleSize - 1) {
                            moveTile(emptyTile.row, emptyTile.col + 1);
                        }
                        break;
                    case 'ArrowRight':
                        // Move tile to the left of empty space
                        if (emptyTile.col > 0) {
                            moveTile(emptyTile.row, emptyTile.col - 1);
                        }
                        break;
                }
            });
        });
    </script>
</body>
</html>
  


